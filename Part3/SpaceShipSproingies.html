<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>Sproingies in WebGL</title>
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
<style type="text/css">
body {
    font-family: Sans-Serif;
    font-size: 0.7em;
    background: #000;
}
#glCanvas {
    display: block;
    border: none;
    width: 100%;
    height: 100%;
}
#infoDialog {
    font-size: 0.9em;
    line-height: 1.5em;
}
.infoIcon {
    display: block;
    float: left;
    border: 0;
    padding: 0;
    margin: 0 16px 5px 0;
}
.version {
    color: #888;
    padding-top: 0.4em;
}
.version2, .showFPS {
    display: block;
    font-size: 0.9em;
    position: absolute;
    bottom: 2em;
    left: 1.2em;
    color: #888;
}
.redBox {
    background-color: #FFAAAA;
    padding: 0.5em 1em;
}
#loadingWebGL {
    padding-top: 40%;
    color: #eee;
    text-align: center;
    font-size: 1.2em;
}
#missingWebGL {
    display: none;
    width: 600px;
    font-size: 1.1em;
    background-color: #EDEDED;
    padding: 0.5em 1em;
    margin: 5px auto;
    text-align: center;
    line-height: 1.5em;
}
#missingWebGL a {
    display: block;
    margin-top: 1em;
    font-weight: bold;
}
#toolbar {
    display: block;
    position: fixed;
    left: 0;
    bottom: 20px;
    margin: 0 auto;
    text-align: center;
    width: 100%;
}
#toolbar .ui-button {
    margin-right: 0.4em;
}
.sliderBox {
    display: block;
    float: left;
    text-align: center;
    border: 1px solid #A6C9E2;
    margin: 5px;
    padding: 2px 10px;
    width: 5em;
}
.sliderBox p {
    clear: both;
    margin: 5px 0;
    line-height: 1.4em;
}
#settingsSliders span {
	height: 140px;
	display: block;
	margin: 0 auto;
}
#glCanvas {
    /* display will be set to "block" after javascript confirms WebGL availability. */
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -10;
}
</style>

<!--
 ** Please read the credits & software licenses:
 ** https://bitbucket.org/emackey/sproingies/wiki/Licenses
 -->
<link rel="stylesheet" href="css/start/jquery-ui-1.8.13.custom.css" />
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="jquery-1.5.1.min.js"></script>
<script type="text/javascript" src="jquery-ui-1.8.13.custom.min.js"></script>

<script type="text/javascript" src="S1_b.js"></script>
<script type="text/javascript" src="spaceShip.js"></script>
<!--
 ** Sproingie fragment & vertex shaders
 -->
<script id="shader-fs-sproingie" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision highp float;
  #endif
  
  //
  // This is the fragment shader for the Sproingies.
  //
  uniform vec4 uKeyLightColor;
  uniform vec3 uKeyLightPos;  // Light positions should be premultiplied with thier own view matrix.
  uniform vec4 uFillLightColor;
  uniform vec3 uFillLightPos;
  uniform vec4 uMaterialColor;
  uniform vec4 uMaterialSpecular;
  uniform vec4 uMaterialAltColor;

  varying vec3 vNormal;
  varying vec4 vViewPos;
  varying vec2 vUVCoords;

  void pointLight(in vec3 N, in vec3 V, in float shininess,
                  inout vec4 diffuse, inout vec4 specular,
                  in vec4 lightColor, in vec3 lightPos)
  {
    vec3 D = lightPos - V;
    vec3 L = normalize(D);

    float nDotL = dot(N,L);

    if (nDotL > 0.0)
    {   
        vec3 halfVector = normalize(L + vec3(0.0, 0.0, 1.0));
        float pf = pow(max(0.0, dot(N, halfVector)), shininess);

        diffuse  += lightColor * nDotL;
        specular += lightColor * pf;
    }
  }
  
  float modf(float x, float y) {
    return x - (y * floor(x/y));
  }
  
  void main(void) {
    vec3 n = normalize(vNormal);
   
    vec4 diffuse  = vec4(0.0);
    vec4 specular = vec4(0.0);

    pointLight(n, vViewPos.xyz, 50.0, diffuse, specular, uKeyLightColor, uKeyLightPos);
    pointLight(n, vViewPos.xyz, 50.0, diffuse, specular, uFillLightColor, uFillLightPos);

    vec4 surfaceColor = uMaterialColor;
    if (modf(floor(vUVCoords.y), 2.0) > 0.5) {
        surfaceColor = uMaterialAltColor;
    }

    vec4 color = (diffuse  * surfaceColor) +
                 (specular * uMaterialSpecular);
                
    color = clamp(vec4(color.rgb, 1.0), 0.0, 1.0);
   
    gl_FragColor = color;
  }
</script>

<script id="shader-vs-sproingie" type="x-shader/x-vertex">
  //
  // This is the vertex shader for the Sproingies.
  //
  attribute vec3 aVertexPosition;
  attribute vec3 aVertexNormal;
  attribute vec2 aUVCoords;

  uniform mat4 uMVMatrix;
  uniform mat4 uProjMatrix;
  uniform mat3 uNormalMatrix;

  varying vec3 vNormal;
  varying vec4 vViewPos;
  varying vec2 vUVCoords;

  void main(void) {
    vNormal = normalize(uNormalMatrix * aVertexNormal);
    vViewPos = uMVMatrix * vec4(aVertexPosition, 1.0);
    vUVCoords = aUVCoords;
    gl_Position = uProjMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>


<!--
 ** Sproingie explosion fragment & vertex shaders
 -->
<script id="shader-fs-boom" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision highp float;
  #endif
  
  //
  // This is the fragment shader for exploding Sproingies.
  //
  uniform vec4 uColor;
  uniform sampler2D uDotSampler;

  void main(void) {
    float alpha = texture2D(uDotSampler, gl_PointCoord).r;
    gl_FragColor = vec4(uColor.rgb, alpha);
    if (alpha < 0.0001) {
      discard;
    }
  }
</script>

<script id="shader-vs-boom" type="x-shader/x-vertex">
  //
  // This is the vertex shader for exploding Sproingies.
  //
  attribute vec3 aVertexPosition;

  uniform mat4 uMVMatrix;
  uniform mat4 uProjMatrix;
  uniform float uPointSize;

  void main(void) {
    gl_PointSize = uPointSize;
    gl_Position = uProjMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>


<!--
 ** Ground fragment & vertex shaders
 -->
<script id="shader-fs-ground" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision highp float;
  #endif
  
  //
  // This is the fragment shader for the ground (staircase) under the Sproingies.
  //
  varying vec4 vColor;
  varying vec3 vGroundPos;

  void main(void) {
    // This extra bit of per-pixel logic fades the top & bottom of the staircase to black.
    float dist = clamp((2.0 - abs(vGroundPos.y / 15.0)), 0.0, 1.0);
    
    // You can swap the commented line for the one below to
    // see the fadeout zone in red, for debugging/adjusting.
    //gl_FragColor = vec4(1.0-dist, (vColor.gb * dist), 1.0);  // Red fadeout zone
    gl_FragColor = vec4((vColor.rgb * dist), 1.0);
  }
</script>

<script id="shader-vs-ground" type="x-shader/x-vertex">
  //
  // This is the vertex shader for the ground (staircase) under the Sproingies.
  //
  attribute vec3 aVertexPosition;
  attribute vec3 aVertexNormal;

  uniform mat4 uMVMatrix;
  uniform mat4 uProjMatrix;
  uniform mat3 uNormalMatrix;

  uniform vec4 uKeyLightColor;
  uniform vec3 uKeyLightPos;  // Light positions should be premultiplied with thier own view matrix.
  uniform vec4 uFillLightColor;
  uniform vec3 uFillLightPos;
  uniform vec4 uMaterialColor;
  uniform vec4 uMaterialSpecular;
  uniform vec4 uMaterialAltColor;
  uniform vec3 uGroundPos;

  varying vec4 vColor;
  varying vec3 vGroundPos;
  
  // This is a rare case where per-vertex lighting looks nicer than per-pixel.
  // With per-vertex, a group of ground cube side walls all have different
  // shades, and offer some contrast from each other.  But with per-pixel lit
  // ground cubes, all the side walls blend seamlessly and the edges disappear.
  // So we light the ground per-vertex, and we light the Sproingies per-pixel.

  void pointLight(in vec3 N, in vec3 V, in float shininess,
                  inout vec4 diffuse, inout vec4 specular,
                  in vec4 lightColor, in vec3 lightPos)
  {
    vec3 D = lightPos - V;
    vec3 L = normalize(D);

    float nDotL = dot(N,L);

    if (nDotL > 0.0)
    {
        vec3 halfVector = normalize(L + vec3(0.0, 0.0, 1.0));
        float pf = pow(max(0.0, dot(N, halfVector)), shininess);

        diffuse  += lightColor * nDotL;
        specular += lightColor * pf;
    }
  }
  
  void main(void) {
    vec3 vNormal = normalize(uNormalMatrix * aVertexNormal);
    vec4 vViewPos = uMVMatrix * vec4(aVertexPosition, 1.0);
    vGroundPos = aVertexPosition + uGroundPos;
    gl_Position = uProjMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    
    vec3 n = normalize(vNormal);
    vec4 diffuse  = vec4(0.0);
    vec4 specular = vec4(0.0);

    vec3 viewPos3 = (vec3 (vViewPos)) / vViewPos.w;
    pointLight(n, viewPos3, 50.0, diffuse, specular, uKeyLightColor, uKeyLightPos);
    pointLight(n, viewPos3, 50.0, diffuse, specular, uFillLightColor, uFillLightPos);
    
    vec4 color = (diffuse  * uMaterialColor) +
                 (specular * uMaterialSpecular);

    // Make the tops of the ground a lighter color.
    if (aVertexNormal.y > 0.5) {
        // Arbitrary gamma tweaking, because it looks like the original when I do this.
        diffuse = 1.0 - ((1.0 - diffuse) * 0.8);
        specular = 1.0 - ((1.0 - specular) * 0.8);
    
        color = // tops
          (diffuse  * vec4(0.392157, 0.784314, 0.941176, 1.0)) +
          (specular * vec4(0.2, 0.2, 0.2, 1.0));
    }
                
    vColor = clamp(vec4(color.rgb, 1.0), 0.0, 1.0);
  }
</script>

<script id="spaceShip-shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif

    //varying vec4 vColor;
    //varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;

    uniform float uMaterialShininess;

    uniform bool uShowSpecularHighlights;
    uniform bool uUseLighting;
    uniform bool uUseTextures;

    uniform vec3 uAmbientColor;

    uniform vec3 uPointLightingLocation;
    uniform vec3 uPointLightingSpecularColor;
    uniform vec3 uPointLightingDiffuseColor;

    uniform sampler2D uSampler;

    void main(void) {
        vec3 lightWeighting;
        if (!uUseLighting) {
            lightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);
            vec3 normal = normalize(vTransformedNormal);

            float specularLightWeighting = 0.0;
            if (uShowSpecularHighlights) {
                vec3 eyeDirection = normalize(-vPosition.xyz);
                vec3 reflectionDirection = reflect(-lightDirection, normal);

                specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
            }

            float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
            lightWeighting = uAmbientColor
                + uPointLightingSpecularColor * specularLightWeighting
                + uPointLightingDiffuseColor * diffuseLightWeighting;
        }

        vec4 fragmentColor;
        if (uUseTextures) {
            //fragmentColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        } else {
            fragmentColor = vec4(0.25, 0.41, 0.88, 1.0);
        }
           
        gl_FragColor = vec4(fragmentColor.rgb * lightWeighting, fragmentColor.a);
    }
</script>


<script id="spaceShip-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;
    
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;
    
    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>



<script type="text/javascript">
var DEFAULT_NUM_SPROINGIES = 42;
var DEFAULT_SPEED          = 20;
var DEFAULT_GROUND         =  2;
var DEFAULT_WEIRDNESS      =  4;

var CAMERA_SLIDE_RATE = 0.998;
var BOOM_STAGE = 50.0;
var S_RES = 28;
var M_TWOPI = Math.PI * 2.0;
var DegToRad = Math.PI / 180.0;

// Bits for m_weirdBits field in Sproingies.
var SP_BIT_AIRDROP         = 1;
var SP_BIT_STRIPES         = 2;
var SP_BIT_FAT             = 4;

var sproingieList = [];
var spaceShipList = [];
var mouseDown = -1;
var lastMouseX = 0;
var lastMouseY = 0;
var target_wait = 0.0001, max_target_wait = 100.0;
var ground = 0.0, rotx = 0.0, roty = -45.0, dist = 32.0;
var target_rx = 0.0, target_ry = -45.0, target_dist = 32.0;
var lookAway = 1.5;
var looking = -0.5;
var howfast = DEFAULT_SPEED;
var groundlevel = DEFAULT_GROUND;
var weirdness = DEFAULT_WEIRDNESS;

var gl;  // the WebGL context
var glCanvasName = "glCanvas";

var MAX_TOOLBAR_LIFE = 5;
var TOOLBAR_FADE_SPEED = 500;
var toolbarLife = MAX_TOOLBAR_LIFE;
var toolbarVisible = true;
var fpsFrames = 0, fpsTime = 0;
var lastTime = 0;
var isPaused = false;

var groundBuffers;
var sproingieBuffers;
var sproingieBoomBuffers;
var groundShaderProgram;
var sproingieShaderProgram;
var SsShaderProgram;
var sproingieBoomShaderProgram;
var dotTexture;
var mvMatrixStack = [];

var spaceShipVertexPositionBuffer;
var spaceShipVertexNormalBuffer;
var spaceShipVertexTextureCoordBuffer;
var spaceShipVertexIndexBuffer;
var spaceShipVertexColorBuffer;


//                  Misc helpful URLs
//  Sproingie Wiki: https://bitbucket.org/emackey/sproingies/wiki/
//          JSLint: http://www.jslint.com/
//      WebGL Spec: http://www.khronos.org/registry/webgl/specs/latest/
//       GLSL Spec: http://www.opengl.org/sdk/docs/manglsl/
//    glMatrix lib: http://code.google.com/p/glmatrix/
// WebGL Inspector: http://benvanik.github.com/WebGL-Inspector/

//
// Initialize WebGL
//
function initGL(canvas) {
    try {
        gl = WebGLUtils.setupWebGL(canvas);
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    }
    catch (ex) { }

    if (gl) {
        document.getElementById("loadingWebGL").style.display = "none";
        document.getElementById("glCanvas").style.display = "block";
        resizeGL();
    }
    else {
        document.getElementById("loadingWebGL").style.display = "none";
        document.getElementById("missingWebGL").style.display = "block";
        $("#play,#showInspector,#showSettings").button("option", "disabled", true);
    }
}

function resizeGL() {
    var canvas = document.getElementById(glCanvasName);
    gl.viewportWidth = canvas.width = canvas.clientWidth;
    gl.viewportHeight = canvas.height = canvas.clientHeight;
    //document.getElementById("info").innerHTML = "Size " + gl.viewportWidth + " x " + gl.viewportHeight;
}

//
// Fetch a shader from another script block, and compile it.
//
function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
        return null;
    }

    var shader;
    if (shaderScript.type === "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type === "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }

    gl.shaderSource(shader, shaderScript.textContent);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(id + " compile error:\n\n" + gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}

//
// Init a shader program.
//
function initShaders(shaderProgram, fsName, vsName) {
    var fragmentShader = getShader(gl, fsName);
    var vertexShader = getShader(gl, vsName);

    if ((fragmentShader !== null) && (vertexShader !== null)) {
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
    gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

    //  attribute vec2 aUVCoords;
    shaderProgram.aUVCoords = gl.getAttribLocation(shaderProgram, "aUVCoords");
    if (shaderProgram.aUVCoords) {
        gl.enableVertexAttribArray(shaderProgram.aUVCoords);
    }

    // Vertex shader uniforms
    //  uniform mat4 uMVMatrix;
    //  uniform mat4 uProjMatrix;
    //  uniform mat4 uNormalMatrix;
    //  uniform vec3 uGroundPos;
    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uProjMatrix");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.normalMatrixUniform = gl.getUniformLocation(shaderProgram, "uNormalMatrix");
    shaderProgram.groundPosUniform = gl.getUniformLocation(shaderProgram, "uGroundPos");

    // Fragment shader uniforms
    //  uniform vec4 uKeyLightColor;
    //  uniform vec3 uKeyLightPos;  // Light positions should be premultiplied with thier own view matrix.
    //  uniform vec4 uFillLightColor;
    //  uniform vec3 uFillLightPos;
    //  uniform vec4 uMaterialColor;
    //  uniform vec4 uMaterialSpecular;
    //  uniform vec4 uMaterialAltColor;
    shaderProgram.uKeyLightColor = gl.getUniformLocation(shaderProgram, "uKeyLightColor");
    shaderProgram.uKeyLightPos = gl.getUniformLocation(shaderProgram, "uKeyLightPos");
    shaderProgram.uFillLightColor = gl.getUniformLocation(shaderProgram, "uFillLightColor");
    shaderProgram.uFillLightPos = gl.getUniformLocation(shaderProgram, "uFillLightPos");
    shaderProgram.uMaterialColor = gl.getUniformLocation(shaderProgram, "uMaterialColor");
    shaderProgram.uMaterialSpecular = gl.getUniformLocation(shaderProgram, "uMaterialSpecular");
    shaderProgram.uMaterialAltColor = gl.getUniformLocation(shaderProgram, "uMaterialAltColor");
}

function initspaceShipShaders() {
    var fragmentShader = getShader(gl, "spaceShip-shader-fs");
    var vertexShader = getShader(gl, "spaceShip-shader-vs");

    SsShaderProgram = gl.createProgram();
    gl.attachShader(SsShaderProgram, vertexShader);
    gl.attachShader(SsShaderProgram, fragmentShader);
    gl.linkProgram(SsShaderProgram);

    if (!gl.getProgramParameter(SsShaderProgram, gl.LINK_STATUS)) {
alert("Could not initialise shaders");
    }

    gl.useProgram(SsShaderProgram);

    SsShaderProgram.vertexPositionAttribute = gl.getAttribLocation(SsShaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(SsShaderProgram.vertexPositionAttribute);
    
    SsShaderProgram.vertexColorAttribute = gl.getAttribLocation(SsShaderProgram, "aVertexColor");
    gl.enableVertexAttribArray(SsShaderProgram.vertexColorAttribute);

    SsShaderProgram.vertexNormalAttribute = gl.getAttribLocation(SsShaderProgram, "aVertexNormal");
    gl.enableVertexAttribArray(SsShaderProgram.vertexNormalAttribute);

    SsShaderProgram.textureCoordAttribute = gl.getAttribLocation(SsShaderProgram, "aTextureCoord");
    gl.enableVertexAttribArray(SsShaderProgram.textureCoordAttribute);
    
    SsShaderProgram.pMatrixUniform = gl.getUniformLocation(SsShaderProgram, "uPMatrix");
    SsShaderProgram.mvMatrixUniform = gl.getUniformLocation(SsShaderProgram, "uMVMatrix");
    SsShaderProgram.nMatrixUniform = gl.getUniformLocation(SsShaderProgram, "uNMatrix");
    SsShaderProgram.samplerUniform = gl.getUniformLocation(SsShaderProgram, "uSampler");
    SsShaderProgram.materialShininessUniform = gl.getUniformLocation(SsShaderProgram, "uMaterialShininess");
    SsShaderProgram.showSpecularHighlightsUniform = gl.getUniformLocation(SsShaderProgram, "uShowSpecularHighlights");
    SsShaderProgram.useTexturesUniform = gl.getUniformLocation(SsShaderProgram, "uUseTextures");
    SsShaderProgram.useLightingUniform = gl.getUniformLocation(SsShaderProgram, "uUseLighting");
    SsShaderProgram.ambientColorUniform = gl.getUniformLocation(SsShaderProgram, "uAmbientColor");
    SsShaderProgram.pointLightingLocationUniform = gl.getUniformLocation(SsShaderProgram, "uPointLightingLocation");
    SsShaderProgram.pointLightingSpecularColorUniform = gl.getUniformLocation(SsShaderProgram, "uPointLightingSpecularColor");
    SsShaderProgram.pointLightingDiffuseColorUniform = gl.getUniformLocation(SsShaderProgram, "uPointLightingDiffuseColor");
}






function initBoomShaders(shaderProgram, fsName, vsName) {
    var fragmentShader = getShader(gl, fsName);
    var vertexShader = getShader(gl, vsName);

    if ((fragmentShader !== null) && (vertexShader !== null)) {
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    // Vertex shader uniforms
    //  uniform mat4 uMVMatrix;
    //  uniform mat4 uProjMatrix;
    //  uniform float uPointSize;
    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uProjMatrix");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.uPointSize = gl.getUniformLocation(shaderProgram, "uPointSize");
    shaderProgram.groundPosUniform = null;

    // Fragment shader uniforms
    //  uniform vec4 uColor;
    //  uniform sampler2D uDotSampler;
    shaderProgram.uColor = gl.getUniformLocation(shaderProgram, "uColor");
    shaderProgram.uDotSampler = gl.getUniformLocation(shaderProgram, "uDotSampler");
}




//
// Textures
//
function handleLoadedTexture(texture) {
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    gl.generateMipmap(gl.TEXTURE_2D);

    gl.bindTexture(gl.TEXTURE_2D, null);
}

function initTextures() {
    dotTexture = gl.createTexture();
    dotTexture.image = new Image();
    dotTexture.image.onload = function() {
        handleLoadedTexture(dotTexture);
    };
    dotTexture.image.src = "images/dot.png";
}

//
// Set various uniforms
//
function setProjectionUniforms(shaderProgram, pMatrix, groundPos) {
    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
    if (shaderProgram.groundPosUniform !== null) {
        gl.uniform3f(shaderProgram.groundPosUniform, groundPos[0], groundPos[1], groundPos[2]);
    }
}


function setMatrixUniforms(shaderProgram, mvMatrix) {
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

    // modelview inverse = transpose(inverse(mv))
    var normalMatrix = mat3.create();
    mat4.toInverseMat3(mvMatrix, normalMatrix);
    mat3.transpose(normalMatrix);
    gl.uniformMatrix3fv(shaderProgram.normalMatrixUniform, false, normalMatrix);
}

function setspaceShipMatrixUniforms(shaderProgram, pMatrix, mvMatrix) {
    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    
    var normalMatrix = mat3.create();
    mat4.toInverseMat3(mvMatrix, normalMatrix);
    mat3.transpose(normalMatrix);
    gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
}


function setLights(shaderProgram, lightMatrix) {
    var keyPos = [16.0, 10.0, -4.0];
    mat4.multiplyVec3(lightMatrix, keyPos);
    gl.uniform4f(shaderProgram.uKeyLightColor, (254 / 255.0), (239 / 255.0), (203 / 255.0), 1.0);
    gl.uniform3f(shaderProgram.uKeyLightPos, keyPos[0], keyPos[1], keyPos[2]);

    var fillPos = [4.0, 0.0, 24.0];
    mat4.multiplyVec3(lightMatrix, fillPos);
    gl.uniform4f(shaderProgram.uFillLightColor, (0.4 * 213 / 255.0), (0.4 * 205 / 255.0), (0.4 * 235 / 255.0), 1.0);
    gl.uniform3f(shaderProgram.uFillLightPos, fillPos[0], fillPos[1], fillPos[2]);
}

function setMaterial(shaderProgram, r, g, b, specular, altR, altG, altB) {
    gl.uniform4f(shaderProgram.uMaterialColor, r, g, b, 1.0);
    gl.uniform4f(shaderProgram.uMaterialSpecular, specular, specular, specular, 1.0);
    gl.uniform4f(shaderProgram.uMaterialAltColor, altR, altG, altB, 1.0);
}

function setBoomUniforms(shaderProgram, mvMatrix, r, g, b, pointSize) {
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    gl.uniform4f(shaderProgram.uColor, r, g, b, 1.0);
    gl.uniform1f(shaderProgram.uPointSize, pointSize);
}

//
// Misc helper functions
//
function myrand(range) {
    return Math.floor(Math.random() * range);
}

function XtoY(x, y) {
	var z = Math.abs(x);
	if (z < 1e-20) {
		return 0.0;
	}

	var a = Math.exp(y * Math.log(z));

	if (x < 0) {
		a = -a;
	}
	return a;
}

function MakeNormal(v1, v2, normals) {
	normals.push((v2[1] * v1[2]) - (v1[1] * v2[2]),
				 (v2[2] * v1[0]) - (v1[2] * v2[0]),
				 (v2[0] * v1[1]) - (v1[0] * v2[1]));
}

//
// spaceShip object declaration
//
function spaceShip(index, max) {
	this.m_X = 0;
	this.m_Y = 0;
	this.m_Z = 0;
	this.m_weirdBits = 0;
	this.m_life = ((-index * ((max > 19) ? 1.0 : 4.0)) - 2.0);
	this.m_stage = 0.0;
	this.m_speed = 0.0;
	this.m_boxiness = 0.02;
	this.m_width = 121.0;
	this.m_R = (40 + myrand(200)) / 255.0;
	this.m_G = (40 + myrand(200)) / 255.0;
	this.m_B = (40 + myrand(200)) / 255.0;
	this.m_index = index;
}

spaceShip.prototype.ResetspaceShip = function() {
    this.m_life = (-30 + myrand(28));
};

spaceShip.prototype.CheckCollision = function(maxStage) {
    var len = spaceShipList.length;
    var t2;

    for (t2 = 0; t2 < len; ++t2) {
        if ((t2 !== this.m_index) && (this.m_X === spaceShipList[t2].m_X) &&
            (this.m_Y === spaceShipList[t2].m_Y) && (this.m_Z === spaceShipList[t2].m_Z) &&
            (spaceShipList[t2].m_life > 10.0) && (spaceShipList[t2].m_stage < maxStage)) {
            return true;
        }
    }
    return false;
};

spaceShip.prototype.AdvancespaceShip = function(nextStage) {
    var g_higher, g_back;
    var index = this.m_index;
    var useDifferentSpeeds = ((weirdness > 1) && (index > 1));

    if (this.m_life > 0.0) {
        if (this.m_stage < BOOM_STAGE) {
            nextStage *= this.m_speed;
        }

        if ((this.m_stage += nextStage) >= 12.0) {
            if (this.m_stage >= BOOM_STAGE) {
                if ((this.m_R -= nextStage * 0.08) < 0.0) { this.m_R = 0.0; }
                if ((this.m_G -= nextStage * 0.08) < 0.0) { this.m_G = 0.0; }
                if ((this.m_B -= nextStage * 0.08) < 0.0) { this.m_B = 0.0; }

                if ((this.m_life -= nextStage) <= 0.0000001) {
                    this.ResetspaceShip();
                }
                return;
            }
            this.m_X += 1;
            this.m_Y -= 2;
            this.m_Z += 1;
            this.m_stage -= 12.0;

            if ((this.m_life > 10.0) && this.CheckCollision(6.0)) {
                this.m_life = 10.0;
                this.m_stage = BOOM_STAGE;
                if ((this.m_R += 0.5) > 1.0) { this.m_R = 1.0; }
                if ((this.m_G += 0.5) > 1.0) { this.m_G = 1.0; }
                if ((this.m_B += 0.5) > 1.0) { this.m_B = 1.0; }
            }
        }

        if (this.m_life < 9.0) {
            if (this.m_stage < 1.0) {
                this.m_stage -= nextStage * 2.0;
                if (this.m_stage < -10.0) {
                    this.ResetspaceShip();
                }
            }
        }
        else {
            this.m_life -= nextStage;
        }
    }
    else if ((this.m_life += nextStage) >= 0.0) {
        // A spaceShip is born. Select the birthplace.

        if ((index > 10) && (groundlevel > 1)) { // High-numbered Sproinge, Gadzooks ground...
            g_higher = -5 + myrand(9); // ...means large birth area.
            g_back = -8 + myrand(17);
        }
        else if ((index > 5) && (groundlevel > 0)) { // Medium-number spaceShip, Lots of ground
            g_higher = -5 + myrand(9); // medium-sized birth area.
            g_back = -4 + myrand(9);
        }
        else if (index > 1) { // Small ID numbered spaceShips born to small ground area.
            g_higher = -3 + myrand(5);
            g_back = -2 + myrand(5);
        }
        else if (index === 1) { // "Second" spaceShip stays near center.
            g_higher = -2 + myrand(3);
            g_back = -1 + myrand(3);
        }
        else { // "Main" spaceShip stays in center.
            g_higher = -1;
            g_back = 0;
        }

        if (useDifferentSpeeds && (this.m_index > 1)) {
            g_higher += 3;
        }

        this.m_X = (-g_higher - g_back);
        this.m_Y = (g_higher * 2);
        this.m_Z = (g_back - g_higher);
        this.m_life = (40 + myrand(200));
        this.m_stage = -10.0;
        this.m_weirdBits = 0;
        this.m_boxiness = 0.02;
        this.m_width = 1.0;

        if (weirdness > 0) {
            this.m_weirdBits |= SP_BIT_AIRDROP;

            var probability = 52 - (weirdness * 2);

            if (probability < 2) {
                probability = 2;
            }

            if ((probability < 4) || (myrand(Math.floor(probability / 8)) === 0)) {
                if (myrand(probability) === 0) {
                    this.m_weirdBits |= SP_BIT_STRIPES;
                }
                if (myrand(probability) === 0) {
                    this.m_weirdBits |= SP_BIT_FAT;
                }
                if (myrand(probability) === 0) {
                    this.m_boxiness = (Math.random() * 0.2);
                }
                if (myrand(probability) === 0) {
                    this.m_width = (Math.random() + 0.4);
                }
            }
        }

          this.m_R = 1.0;
          this.m_G = (40 + myrand(200)) / 255.0;
          this.m_B = (40 + myrand(200)) / 255.0;

        if (useDifferentSpeeds) {
            this.m_speed = (this.m_R * 2.0) + (1.0 - (40.0 / 255.0));
        }
        else {
            this.m_speed = 1.0;
        }

        // This makes pink-compatible spaceShips for a possible Valentine's Day easter egg.
        // this.m_R = 1.0;
        // this.m_G = (40 + myrand(200)) / 255.0;
        // this.m_B = (40 + myrand(200)) / 255.0;
        // This makes black and white spaceShips for gray stairs.
        // if (myrand(2)) {
        // this.m_R = this.m_G = this.m_B = 40.0f / 255.0;
        // }
        // else {
        // this.m_R = this.m_G = this.m_B = 240.0f / 255.0;
        // }

        if (this.CheckCollision(0.0)) {
            // If one is already being born, just wait.
            this.m_life = -1.0;
        }
    }
};


spaceShip.prototype.RenderspaceShip = function(spaceShipBuffers, mvMatrix) {
    var spaceShipMatrix = mat4.create(mvMatrix);
    var flipspaceShipV = false;

if (this.m_stage < 0.0) { // -10.0 to just below 0.0
if (!(this.m_weirdBits & SP_BIT_AIRDROP)) {
mat4.translate(spaceShipMatrix, [this.m_X,
this.m_Y + (this.m_stage / 9.0),
this.m_Z]);
}
else {
if (this.m_life < 10.0) { // spaceShip dies of old age
var tall = Math.pow((this.m_stage + 10.0) / 10.0, 2.0);
var wide = ((this.m_stage + 10.0) / 10.0);

mat4.translate(spaceShipMatrix, [this.m_X + 0.5,
this.m_Y + 0.01,
this.m_Z - 0.5]);
mat4.scale(spaceShipMatrix, [wide, tall, wide]);
mat4.translate(spaceShipMatrix, [-0.5, -0.01, 0.5]);
}
else { // spaceShip being born
var drop = 10.0 - ((this.m_stage + 10.0) *
(this.m_stage + 10.0) / 10.0);

mat4.translate(spaceShipMatrix, [this.m_X + 0.5,
this.m_Y + drop,
this.m_Z - 0.5]);
mat4.scale(spaceShipMatrix, [
(this.m_stage + 10.0) / 10.0,
(this.m_stage + 10.0) / 10.0,
(this.m_stage + 10.0) / 10.0]);
mat4.translate(spaceShipMatrix, [-0.5, 0.0, 0.5]);
}
}
this.ParametricspaceShip(0.0, spaceShipMatrix);
drawspaceShip(spaceShipMatrix);
}
else if (this.m_stage >= 6.0) {
mat4.translate(spaceShipMatrix, [this.m_X + 1, this.m_Y - 1, this.m_Z - 1]);
mat4.rotate(spaceShipMatrix, -90.0 * DegToRad, [0.0, 1.0, 0.0]);
flipspaceShipV = true;
this.ParametricspaceShip(this.m_stage - 6.0, spaceShipMatrix);
drawspaceShip(spaceShipMatrix);
}
else {
mat4.translate(spaceShipMatrix, [this.m_X, this.m_Y, this.m_Z]);
this.ParametricspaceShip(this.m_stage, spaceShipMatrix);
drawspaceShip(spaceShipMatrix);
}
};

spaceShip.prototype.ParametricspaceShip = function(fstage, spaceShipMatrix){
    var fMoveX = (fstage > 2.0) ? ((Math.cos((fstage-2.0)*Math.PI*0.25)*-0.5+0.5)*fstage/6.0):0.0;
    var fMoveY = (fstage>2.0)?((fstage<4.0)?(0.25+0.25*Math.cos((fstage-4.0)*Math.PI*0.5)):(0.5-0.1325*((fstage-4.0)*(fstage-4.0)))):0.0;
    var fRotateZ = (fstage>1)?(Math.cos((fstage-1)*Math.PI/5.0)*-90.0+90.0):0.0;
    mat4.translate(spaceShipMatrix, [fMoveX + 0.5, fMoveY, -0.5]);
    mat4.rotate(spaceShipMatrix, fRotateZ * DegToRad, [0.0, 0.0, -1.0]);
};

function drawspaceShip(mvMatrix) {

    mvPushMatrix(mvMatrix);
    mat4.translate(mvMatrix, [0, 0.35, 0]);
    mat4.scale(mvMatrix, [.03, .04, .04]);

        gl.uniform1i(SsShaderProgram.showSpecularHighlightsUniform, true);

        gl.uniform1i(SsShaderProgram.useLightingUniform, true);
        gl.uniform3f(SsShaderProgram.ambientColorUniform, 0.5, 0.5, 0.5);
        gl.uniform3f(SsShaderProgram.pointLightingLocationUniform, -.1, .04, -.020);
        gl.uniform3f(SsShaderProgram.pointLightingSpecularColorUniform,3,3,3);
        gl.uniform3f(SsShaderProgram.pointLightingDiffuseColorUniform,0.8,0.8,0.8);

    gl.uniform1i(SsShaderProgram.samplerUniform, 0);

    gl.uniform1f(SsShaderProgram.materialShininessUniform, 32.0);

    gl.bindBuffer(gl.ARRAY_BUFFER, spaceShipVertexPositionBuffer);
    gl.vertexAttribPointer(SsShaderProgram.vertexPositionAttribute, spaceShipVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, spaceShipVertexTextureCoordBuffer);
    gl.vertexAttribPointer(SsShaderProgram.textureCoordAttribute, spaceShipVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, spaceShipVertexNormalBuffer);
    gl.vertexAttribPointer(SsShaderProgram.vertexNormalAttribute, spaceShipVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, spaceShipVertexColorBuffer);
    gl.vertexAttribPointer(SsShaderProgram.vertexColorAttribute, spaceShipVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, spaceShipVertexIndexBuffer);
    setMatrixUniforms(SsShaderProgram, mvMatrix);
    gl.drawElements(gl.TRIANGLES, spaceShipVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    mvPopMatrix(mvMatrix);
}




function mvPushMatrix(mvMatrix) {
    var copy = mat4.create();
    mat4.set(mvMatrix, copy);
    mvMatrixStack.push(copy);
}

function mvPopMatrix(mvMatrix) {
    if (mvMatrixStack.length == 0) {
        throw "Invalid popMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
    return mvMatrix;
}






//
// Sproingie object declaration
//
function Sproingie(index, max) {
	this.m_X = 0;
	this.m_Y = 0;
	this.m_Z = 0;
	this.m_weirdBits = 0;
	this.m_life = ((-index * ((max > 19) ? 1.0 : 4.0)) - 2.0);
	this.m_stage = 0.0;
	this.m_speed = 0.0;
	this.m_boxiness = 0.02;
	this.m_width = 1.0;
	this.m_R = 255;
	this.m_G = 255;
	this.m_B = 255;
	this.m_index = index;
}

Sproingie.prototype.ResetSproingie = function() {
    this.m_life = (-30 + myrand(28));
};

Sproingie.prototype.CheckCollision = function(maxStage) {
    var len = sproingieList.length;
    var t2;

    for (t2 = 0; t2 < len; ++t2) {
        if ((t2 !== this.m_index) && (this.m_X === sproingieList[t2].m_X) &&
            (this.m_Y === sproingieList[t2].m_Y) && (this.m_Z === sproingieList[t2].m_Z) &&
            (sproingieList[t2].m_life > 10.0) && (sproingieList[t2].m_stage < maxStage)) {
            return true;
        }
    }
    return false;
};

Sproingie.prototype.AdvanceSproingie = function(nextStage) {
    var g_higher, g_back;
    var index = this.m_index;
    var useDifferentSpeeds = ((weirdness > 1) && (index > 1));

    if (this.m_life > 0.0) {
        if (this.m_stage < BOOM_STAGE) {
            nextStage *= this.m_speed;
        }

        if ((this.m_stage += nextStage) >= 12.0) {
            if (this.m_stage >= BOOM_STAGE) {
                 this.m_R = 255; 
                 this.m_G = 0.0; 
                 this.m_B = 0.0; 

                if ((this.m_life -= nextStage) <= 0.0000001) {
                    this.ResetSproingie();
                }
                return;
            }
            this.m_X += 1;
            this.m_Y -= 2;
            this.m_Z += 1;
            this.m_stage -= 12.0;

            if ((this.m_life > 10.0) && this.CheckCollision(6.0)) {
                this.m_life = 10.0;
                this.m_stage = BOOM_STAGE;
                 this.m_R = 255; 
                this.m_G = 0; 
                this.m_B = 0; 
            }
        }

        if (this.m_life < 9.0) {
            if (this.m_stage < 1.0) {
                this.m_stage -= nextStage * 2.0;
                if (this.m_stage < -10.0) {
                    this.ResetSproingie();
                }
            }
        }
        else {
            this.m_life -= nextStage;
        }
    }
    else if ((this.m_life += nextStage) >= 0.0) {
        // A sproingie is born.  Select the birthplace.

        if ((index > 10) && (groundlevel > 1)) {   // High-numbered Sproinge, Gadzooks ground...
            g_higher = -5 + myrand(9);             // ...means large birth area.
            g_back = -8 + myrand(17);
        }
        else if ((index > 5) && (groundlevel > 0)) { // Medium-number Sproingie, Lots of ground
            g_higher = -5 + myrand(9);               // medium-sized birth area.
            g_back = -4 + myrand(9);
        }
        else if (index > 1) {   // Small ID numbered Sproingies born to small ground area.
            g_higher = -3 + myrand(5);
            g_back = -2 + myrand(5);
        }
        else if (index === 1) {  // "Second" Sproingie stays near center.
            g_higher = -2 + myrand(3);
            g_back = -1 + myrand(3);
        }
        else {   // "Main" Sproingie stays in center.
            g_higher = -1;
            g_back = 0;
        }

        if (useDifferentSpeeds && (this.m_index > 1)) {
            g_higher += 3;
        }

        this.m_X = (-g_higher - g_back);
        this.m_Y = (g_higher * 2);
        this.m_Z = (g_back - g_higher);
        this.m_life = (40 + myrand(200));
        this.m_stage = -10.0;
        this.m_weirdBits = 0;
        this.m_boxiness = 0.02;
        this.m_width = 1.0;

        if (weirdness > 0) {
            this.m_weirdBits |= SP_BIT_AIRDROP;

            var probability = 52 - (weirdness * 2);

            if (probability < 2) {
                probability = 2;
            }

            if ((probability < 4) || (myrand(Math.floor(probability / 8)) === 0)) {
                if (myrand(probability) === 0) {
                    this.m_weirdBits |= SP_BIT_STRIPES;
                }
                if (myrand(probability) === 0) {
                    this.m_weirdBits |= SP_BIT_FAT;
                }
                if (myrand(probability) === 0) {
                    this.m_boxiness = (Math.random() * 0.2);
                }
                if (myrand(probability) === 0) {
                    this.m_width = (Math.random() + 0.4);
                }
            }
        }

   
        this.m_R = (255 + myrand(0)) / 255.0;
        this.m_G = (0 + myrand(0)) / 255.0;
        this.m_B = (0  + myrand(0)) / 255.0;

        if (useDifferentSpeeds) {
            this.m_speed = (this.m_R * 2.0) + (1.0 - (40.0 / 255.0));
        }
        else {
            this.m_speed = 1.0;
        }

        if (this.CheckCollision(0.0)) {
            // If one is already being born, just wait.
            this.m_life = -1.0;
        }
    }
};

Sproingie.prototype.ParametricSproingie = function(fstage, sproingieBuffers, sproingieMatrix) {
	if (fstage < 0.0) { fstage = 0.0; }
	if (fstage > 6.0) { fstage = 6.0; }

	var fMoveX = (fstage > 2.0) ? ((Math.cos((fstage-2.0)*Math.PI*0.25)*-0.5+0.5)*fstage/6.0):0.0;
	var fMoveY = (fstage>2.0)?((fstage<4.0)?(0.25+0.25*Math.cos((fstage-4.0)*Math.PI*0.5)):(0.5-0.1325*((fstage-4.0)*(fstage-4.0)))):0.0;
	var fRotateZ = (fstage>1)?(Math.cos((fstage-1)*Math.PI/5.0)*-90.0+90.0):0.0;
	var fBendHeight = (fstage < 4.0)?(Math.cos(fstage*Math.PI*0.25)*-0.35+0.65):1.0;
	var fBendAngle = (Math.cos(fstage*Math.PI/3.0)*-45.0+45.0)*(6.0-fstage)/3.0;
	var fBulge = ((fstage<2.0)?(Math.sin(fstage*Math.PI*0.5)*0.25):(Math.sin((fstage+2)*Math.PI*0.25)*0.1));
	var fStretch = ((fstage<2.0)?(Math.sin(fstage*Math.PI*0.5)*-0.25+1.0):(Math.sin((fstage+2.0)*Math.PI*0.25)*-0.2+1.0));

	if (this.m_weirdBits & SP_BIT_AIRDROP) {
		// Old age Sproingie squishes flat against stair.
		if ((this.m_stage < 0.0) && (this.m_life < 10.0))
		{
			fBulge = (this.m_stage / -4.0);
		}
	}

	// Fat mode
	if ((this.m_weirdBits & SP_BIT_FAT) && (fBulge < 0.4)) {
		fBulge = 0.4;
	}

	// Skinny
	//fBulge -= 0.2f;

	var iU, iV;  // ints
	var cosProfile = new Array(S_RES+1), sinProfile = new Array(S_RES+1);
	var sideProfile = new Array(S_RES+1), radialProfile = new Array(S_RES+1), yProfile = new Array(S_RES+1);
	var u, v, x, y, z, bulge;

	fBendAngle *= (Math.PI / 180.0);
	var fBendRadius = fBendHeight / fBendAngle;
	var fSinBendAngle = Math.sin(fBendAngle);
	var fCosBendAngle = Math.cos(fBendAngle);

	// Add 0.5 to x and z for original sproingie.
	mat4.translate(sproingieMatrix, [fMoveX + 0.5, fMoveY, -0.5]);
	mat4.rotate(sproingieMatrix, fRotateZ * DegToRad, [0.0, 0.0, -1.0]);

	// Build Sproingie shape profiles.
	for (iU = 0; iU <= S_RES; ++iU) {
		v = u = iU / S_RES;

		sinProfile[iU] = Math.sin(M_TWOPI * u);
		cosProfile[iU] = Math.cos(M_TWOPI * u);

		bulge = (XtoY(cosProfile[iU],3.0)*-0.5+0.5) * fBulge;  // This is v-based.
		yProfile[iU] = (Math.atan(v*6.0-3.0)*0.395+0.485) * fStretch;
		sideProfile[iU] = Math.pow(Math.sin(Math.PI*v),0.5)*((v*v-v+1.0)*2.3-1.3+bulge)*0.5;
		radialProfile[iU] = (Math.cos(Math.PI*((8.0*u)+1.0))*this.m_boxiness+1.0)*this.m_width;
	}

    var vertices = [];
	// Generate the vertex array, with singular top and bottom points.
	for (iV = 0; iV <= S_RES; ++iV) {
		for (iU = 0; iU < S_RES; ++iU) {
			if ((iU === 0) || ((iV > 0) && (iV < S_RES))) {
				x = z = sideProfile[iV]*radialProfile[iU];
				x *= sinProfile[iU];
				y = yProfile[iV];
				z *= cosProfile[iU];
				
				var oX = x, oY = y;

				if (fBendAngle > 0.0000001)
				{
					if (oY > fBendHeight)
					{
						x = ((oX - fBendRadius) * fCosBendAngle +
							((oY - fBendHeight) * fSinBendAngle) + fBendRadius);

						y = ((fBendRadius - oX) * fSinBendAngle  +
							((oY - fBendHeight) * fCosBendAngle));
					}
					else if (oY > 0.0)
					{
						x = ((oX - fBendRadius) * Math.cos(oY / fBendRadius) + fBendRadius);
						y = ((fBendRadius - oX) * Math.sin(oY / fBendRadius));
					}
				}
				
				vertices.push(x, y, z);
			}
		}
	}
	
	// If S_RES === 4, that means 4 per row:
	// single, 4, 4, 4, single

	var normals = [];

	// indexof(p(u, v)) === ((v-1) * S_RES) + u + 1
	
	// v1 === p(0, 1)           - p((S_RES / 2), 1)        // South - North
    // v2 === p((S_RES / 4), 1) - p(((S_RES * 3) / 4), 1)  // West - East
    var NorthIndex = 3 * (Math.floor(S_RES/2) + 1);
    var SouthIndex = 3;
	var v1 = [
		vertices[SouthIndex] - vertices[NorthIndex],
		vertices[SouthIndex+1] - vertices[NorthIndex+1],
		vertices[SouthIndex+2] - vertices[NorthIndex+2] ];
    
    var EastIndex = 3 * (Math.floor(S_RES*0.75) + 1);
    var WestIndex = 3 * (Math.floor(S_RES*0.25) + 1);
	var v2 = [
		vertices[WestIndex] - vertices[EastIndex],
		vertices[WestIndex+1] - vertices[EastIndex+1],
		vertices[WestIndex+2] - vertices[EastIndex+2] ];

	MakeNormal(v1, v2, normals);
    
	for (iV = 1; iV < S_RES; ++iV) {
		for (iU = 0; iU < S_RES; ++iU) {
			// v1 === p(u, v-2)   - p(u, v)      // South - North
			// v2 === p(u-1, v-1) - p(u+1, v-1)  // West - East
			
			NorthIndex = 3 * ((iV === (S_RES-1)) ? ((S_RES-1) * S_RES + 1) : (iV * S_RES + iU + 1));
			SouthIndex = 3 * ((iV < 2) ? 0 : ((iV - 2) * S_RES + iU + 1));
			v1 = [
				vertices[SouthIndex] - vertices[NorthIndex],
				vertices[SouthIndex+1] - vertices[NorthIndex+1],
				vertices[SouthIndex+2] - vertices[NorthIndex+2] ];
			
			EastIndex = 3 * ((iU === (S_RES - 1)) ? ((iV - 1) * S_RES + 1) : ((iV - 1) * S_RES + iU + 2));
			WestIndex = 3 * ((iU < 1) ? (iV * S_RES) : ((iV - 1) * S_RES + iU));
			v2 = [
				vertices[WestIndex] - vertices[EastIndex],
				vertices[WestIndex+1] - vertices[EastIndex+1],
				vertices[WestIndex+2] - vertices[EastIndex+2] ];

			MakeNormal(v1, v2, normals);
		}
	}
	
	// v1 === p((S_RES / 2), S_RES-1) - p(0, S_RES-1)                  // North - South
	// v2 === p((S_RES / 4), S_RES-1) - p(((S_RES * 3) / 4), S_RES-1)  // West - East
	
    SouthIndex = 3 * ((S_RES-2) * S_RES + 1);
    NorthIndex = SouthIndex + 3 * (Math.floor(S_RES/2) + 1);
	v1 = [
		vertices[NorthIndex] - vertices[SouthIndex],
		vertices[NorthIndex+1] - vertices[SouthIndex+1],
		vertices[NorthIndex+2] - vertices[SouthIndex+2] ];
    
    WestIndex = SouthIndex + 3 * (Math.floor(S_RES*0.25) + 1);
    EastIndex = SouthIndex + 3 * (Math.floor(S_RES*0.75) + 1);
	v2 = [
		vertices[WestIndex] - vertices[EastIndex],
		vertices[WestIndex+1] - vertices[EastIndex+1],
		vertices[WestIndex+2] - vertices[EastIndex+2] ];

	MakeNormal(v1, v2, normals);

	gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.VertexPosition);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	sproingieBuffers.itemSize = 3;
	sproingieBuffers.numItems = vertices.length / sproingieBuffers.itemSize;

	gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.VertexNormal);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
};

Sproingie.prototype.RenderSproingie = function(sproingieBuffers, mvMatrix) {
    var sproingieMatrix = mat4.create(mvMatrix);
    var flipSproingieV = false;

	if (this.m_stage < 0.0) {    // -10.0 to just below 0.0
	    if (!(this.m_weirdBits & SP_BIT_AIRDROP)) {
			mat4.translate(sproingieMatrix, [this.m_X,
				this.m_Y + (this.m_stage / 9.0),
				this.m_Z]);
		}
		else {
		    if (this.m_life < 10.0) {  // Sproingie dies of old age
			    var tall = Math.pow((this.m_stage + 10.0) / 10.0, 2.0);
			    var wide = ((this.m_stage + 10.0) / 10.0);

				mat4.translate(sproingieMatrix, [this.m_X + 0.5,
					this.m_Y + 0.01,
					this.m_Z - 0.5]);
				mat4.scale(sproingieMatrix, [wide, tall, wide]);
				mat4.translate(sproingieMatrix, [-0.5, -0.01, 0.5]);
			}
			else {    // Sproingie being born
				var drop = 10.0 - ((this.m_stage + 10.0) *
					(this.m_stage + 10.0) / 10.0);

				mat4.translate(sproingieMatrix, [this.m_X + 0.5,
					this.m_Y + drop,
					this.m_Z - 0.5]);
				mat4.scale(sproingieMatrix, [
				    (this.m_stage + 10.0) / 10.0,
					(this.m_stage + 10.0) / 10.0,
					(this.m_stage + 10.0) / 10.0]);
				mat4.translate(sproingieMatrix, [-0.5, 0.0, 0.5]);
			}
		}
		this.ParametricSproingie(0.0, sproingieBuffers, sproingieMatrix);
	}
	else if (this.m_stage >= 6.0) {
		mat4.translate(sproingieMatrix, [this.m_X + 1, this.m_Y - 1, this.m_Z - 1]);
		mat4.rotate(sproingieMatrix, -90.0 * DegToRad, [0.0, 1.0, 0.0]);
		flipSproingieV = true;
		this.ParametricSproingie(this.m_stage - 6.0, sproingieBuffers, sproingieMatrix);
	}
	else {
		mat4.translate(sproingieMatrix, [this.m_X, this.m_Y, this.m_Z]);
		this.ParametricSproingie(this.m_stage, sproingieBuffers, sproingieMatrix);
	}
	
    gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.VertexPosition);
    gl.vertexAttribPointer(sproingieShaderProgram.vertexPositionAttribute,
        sproingieBuffers.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.VertexNormal);
    gl.vertexAttribPointer(sproingieShaderProgram.vertexNormalAttribute,
        sproingieBuffers.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.UVCoords);
    gl.vertexAttribPointer(sproingieShaderProgram.aUVCoords,
        sproingieBuffers.uvItemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms(sproingieShaderProgram, sproingieMatrix);
    if ((this.m_weirdBits & SP_BIT_STRIPES) === 0) {
        setMaterial(sproingieShaderProgram, this.m_R, this.m_G, this.m_B, 0.5,
            this.m_R, this.m_G, this.m_B);
    } else if (!flipSproingieV) {
        setMaterial(sproingieShaderProgram, this.m_R, this.m_G, this.m_B, 0.5,
            1.0 - this.m_R, 1.0 - this.m_G, 1.0 - this.m_B);
    } else {
        setMaterial(sproingieShaderProgram, 1.0 - this.m_R, 1.0 - this.m_G, 1.0 - this.m_B, 0.5,
            this.m_R, this.m_G, this.m_B);
    }
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sproingieBuffers.VertexIndex);
    gl.drawElements(gl.TRIANGLE_STRIP, sproingieBuffers.numIndices, gl.UNSIGNED_SHORT, 0);
};

Sproingie.prototype.RenderSproingieBoom = function(sproingieBuffers, mvMatrix, dist) {
    var sproingieBoomMatrix = mat4.create(mvMatrix);

    mat4.translate(sproingieBoomMatrix, [this.m_X + 0.5, this.m_Y + 0.5, this.m_Z - 0.5]);
    var scale = ((this.m_stage - BOOM_STAGE) * 2.0);
    mat4.scale(sproingieBoomMatrix, [scale, scale, scale]);
    
    var pointsize = ((BOOM_STAGE + 8.0) - this.m_stage) - (dist / 64.0);
    if (pointsize < 1.0) {
        pointsize = 1.0;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBoomBuffers.VertexPosition);
    gl.vertexAttribPointer(sproingieBoomShaderProgram.vertexPositionAttribute,
        sproingieBoomBuffers.itemSize, gl.FLOAT, false, 0, 0);

    setBoomUniforms(sproingieBoomShaderProgram, sproingieBoomMatrix,
        this.m_R, this.m_G, this.m_B, pointsize);
        
    gl.drawArrays(gl.POINTS, 0, sproingieBoomBuffers.numItems);
};

function SproingieTriangleStrip(sproingieBuffers) {
    // Triangle strip
    var indices = [];
    var SouthIndex = (S_RES - 2) * S_RES + 1;
    var NorthIndex = (S_RES - 1) * S_RES + 1;
    
    for (iU = 0; iU < S_RES; ++iU) {
        indices.push(0, iU + 1);
    }
    indices.push(0, 1);
    for (iV = 2; iV < S_RES; ++iV) {
        for (iU = 0; iU < S_RES; ++iU) {
            indices.push((iV - 2) * S_RES + iU + 1, (iV - 1) * S_RES + iU + 1);
        }
        indices.push((iV - 2) * S_RES + 1, (iV - 1) * S_RES + 1);
    }
    for (iU = 0; iU < S_RES; ++iU) {
        indices.push(iU + SouthIndex, NorthIndex);
    }
    indices.push(SouthIndex);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sproingieBuffers.VertexIndex);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    sproingieBuffers.numIndices = indices.length;

    var UVs = [];
    for (iV = 0; iV <= S_RES; ++iV) {
        for (iU = 0; iU < S_RES; ++iU) {
            UVs.push(iU, iV);
            if ((iV === 0) || (iV === S_RES)) {
                break;
            }
        }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.UVCoords);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(UVs), gl.STATIC_DRAW);
    sproingieBuffers.uvItemSize = 2;
    sproingieBuffers.uvNumItems = UVs.length / sproingieBuffers.uvItemSize;
}

function SetMaxSpaceShips(max) {
    var len = spaceShipList.length;
    
    if (len > max) {
        spaceShipList = spaceShipList.slice(0, max);
    }
    else {
        while (len < max) {
            spaceShipList.push(new spaceShip(len, max));
            ++len;
        }
    }
}



function SetMaxSproingies(max) {
    var len = sproingieList.length;
    
    if (len > max) {
        sproingieList = sproingieList.slice(0, max);
    }
    else {
        while (len < max) {
            sproingieList.push(new Sproingie(len, max));
            ++len;
        }
    }
}

  //
  // Compute the groundBuffers
  //
  function computeGround(halfWidth, halfHeight, groundBuffers) {
      var fullWidth = (halfWidth * 2) + 1;
      var fullHeight = (halfHeight * 2);

      var startX = -halfHeight - halfWidth;
      var startY = fullHeight;
      var startZ = halfWidth - halfHeight;

      var vertices = [];
      var normals = [];
      var indices = [];

      var one_normal_group = [
      // Upper top
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
      // Lower top
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
      // Upper left
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
      // Lower left
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
      // Upper right
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
      // Lower right
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0
      ];

      var one_index_group = [
      // Upper top
          0, 1, 2,
          0, 2, 3,
      // Lower top
          4, 5, 6,
          4, 6, 7,
      // Upper left
          8, 9, 10,
          8, 10, 11,
      // Lower left
          12, 13, 14,
          12, 14, 15,
      // Upper right
          16, 17, 18,
          16, 18, 19,
      // Lower right
          20, 21, 22,
          20, 22, 23
      ];

      var addTwentyFour = function(element, index, array) {
          array[index] += 24;
          return true;
      };

      var h;
      for (h = 0; h < fullHeight; ++h) {
          var x = startX + h;
          var y = startY - (h * 2);
          var z = startZ + h;

          var w;
          for (w = 0; w < fullWidth; ++w) {
              normals = normals.concat(one_normal_group);
              indices = indices.concat(one_index_group);
              one_index_group.every(addTwentyFour);
              vertices = vertices.concat([
                // Upper top
			        x,     y, z,
			        x,     y, z - 1,
			        x + 1, y, z - 1,
			        x + 1, y, z,
			    // Lower top
			        x + 1, y - 1, z,
			        x + 1, y - 1, z - 1,
			        x + 2, y - 1, z - 1,
			        x + 2, y - 1, z,
                // Upper left
			        x,     y    , z,
			        x + 1, y    , z,
			        x + 1, y - 1, z,
			        x,     y - 1, z,
                // Lower left
			        x + 1, y - 1, z,
			        x + 2, y - 1, z,
			        x + 2, y - 2, z,
			        x + 1, y - 2, z,
                // Upper right
			        x + 1, y    , z,
			        x + 1, y    , z - 1,
			        x + 1, y - 1, z - 1,
			        x + 1, y - 1, z,
                // Lower right
			        x + 2, y - 1, z,
			        x + 2, y - 1, z - 1,
			        x + 2, y - 2, z - 1,
			        x + 2, y - 2, z
              ]);
              ++x;
              --z;
          }
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, groundBuffers.VertexPosition);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      groundBuffers.itemSize = 3;
      groundBuffers.numItems = vertices.length / groundBuffers.itemSize;

      gl.bindBuffer(gl.ARRAY_BUFFER, groundBuffers.VertexNormal);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, groundBuffers.VertexIndex);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      groundBuffers.numIndices = indices.length;
  }

  function initBuffers() {
      groundBuffers = {};
      groundBuffers.VertexPosition = gl.createBuffer();
      groundBuffers.VertexNormal = gl.createBuffer();
      groundBuffers.VertexIndex = gl.createBuffer();
      
      computeGround(8, 16, groundBuffers);

      sproingieBuffers = {};
      sproingieBuffers.VertexPosition = gl.createBuffer();
      sproingieBuffers.VertexNormal = gl.createBuffer();
      sproingieBuffers.VertexIndex = gl.createBuffer();
      sproingieBuffers.UVCoords = gl.createBuffer();
      SproingieTriangleStrip(sproingieBuffers);

      sproingieBoomBuffers = {};
      sproingieBoomBuffers.VertexPosition = gl.createBuffer();

      gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBoomBuffers.VertexPosition);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(s1_b_PNTS), gl.STATIC_DRAW);
      sproingieBoomBuffers.itemSize = 3;
      sproingieBoomBuffers.numItems = s1_b_PNTS.length / sproingieBoomBuffers.itemSize;

//spaceShips
    var spaceShipData = eval(spaceShipJSON);
    spaceShipVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, spaceShipVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(spaceShipData.vertexNormals), gl.STATIC_DRAW);
    spaceShipVertexNormalBuffer.itemSize = 3;
    spaceShipVertexNormalBuffer.numItems = spaceShipData.vertexNormals.length / 3;
    
    spaceShipVertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, spaceShipVertexTextureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(spaceShipData.vertexTextureCoords), gl.STATIC_DRAW);
    spaceShipVertexTextureCoordBuffer.itemSize = 2;
    spaceShipVertexTextureCoordBuffer.numItems = spaceShipData.vertexTextureCoords.length / 2;
    
    spaceShipVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, spaceShipVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(spaceShipData.vertexPositions), gl.STATIC_DRAW);
    spaceShipVertexPositionBuffer.itemSize = 3;
    spaceShipVertexPositionBuffer.numItems = spaceShipData.vertexPositions.length / 3;
    
    spaceShipVertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, spaceShipVertexIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(spaceShipData.indices), gl.STATIC_DRAW);
    spaceShipVertexIndexBuffer.itemSize = 1;
    spaceShipVertexIndexBuffer.numItems = spaceShipData.indices.length;
    
    spaceShipVertexColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, spaceShipVertexColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1.0,0.0,1.0,1.0]), gl.STATIC_DRAW);
    spaceShipVertexColorBuffer.itemSize = 4;
    spaceShipVertexColorBuffer.numItems = 1;



  }


  function drawScene() {
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    var pMatrix = mat4.create();
	var fov = 88.0;

	if ((gl.viewportWidth > gl.viewportHeight) && (gl.viewportHeight > 0))
	{
	    fov *= (gl.viewportHeight / gl.viewportWidth);
	}
	mat4.perspective(fov, gl.viewportWidth / gl.viewportHeight, 0.1, 2000.0, pMatrix);

	var mvMatrix = mat4.create();
	mat4.identity(mvMatrix);
	
	if (lookAway > 0.0000001) {
	    mat4.rotate(mvMatrix, (1.0 - Math.cos(lookAway)) * Math.PI, [0.0, 1.0, 0.0]);
	}
	mat4.translate(mvMatrix, [0.0, 0.0, -dist / 16.0]);  /* viewing transform  */
	mat4.rotate(mvMatrix, rotx * DegToRad, [1.0, 0.0, 0.0]);
	mat4.rotate(mvMatrix, roty * DegToRad, [0.0, 1.0, 0.0]);

	var worldMatrix = mat4.create(mvMatrix);

    var groundPos = [ground * (-1.0 / 12.0) - 0.75,
		ground * (2.0 / 12.0) - 0.5,
		ground * (-1.0 / 12.0) + 0.75];
    mat4.translate(mvMatrix, groundPos);

    //
    // Render the ground
    //
    gl.useProgram(groundShaderProgram);

    gl.bindBuffer(gl.ARRAY_BUFFER, groundBuffers.VertexPosition);
    gl.vertexAttribPointer(groundShaderProgram.vertexPositionAttribute,
        groundBuffers.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, groundBuffers.VertexNormal);
    gl.vertexAttribPointer(groundShaderProgram.vertexNormalAttribute,
        groundBuffers.itemSize, gl.FLOAT, false, 0, 0);

    setLights(groundShaderProgram, worldMatrix);
    setProjectionUniforms(groundShaderProgram, pMatrix, groundPos);
    setMatrixUniforms(groundShaderProgram, mvMatrix);
    setMaterial(groundShaderProgram,
        0.156863, 0.156863, 0.392157, 0.5,  // Side RGB, Side specularity
        0.392157, 0.784314, 0.941176);      // Top RGB
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, groundBuffers.VertexIndex);
    gl.drawElements(gl.TRIANGLES, groundBuffers.numIndices, gl.UNSIGNED_SHORT, 0);

    //
    // Render the Sproingies!
    //
    gl.useProgram(sproingieShaderProgram);

    setLights(sproingieShaderProgram, worldMatrix);
    setProjectionUniforms(sproingieShaderProgram, pMatrix, groundPos);

    var numSproingies = sproingieList.length;
    var t;

    for (t = 0; t < numSproingies; ++t) {
        if ((sproingieList[t].m_life > 0.0) &&
            (sproingieList[t].m_stage < (BOOM_STAGE - 0.001))) {
            sproingieList[t].RenderSproingie(sproingieBuffers, mvMatrix);
        }
    }
    
 
    // Render spaceShip
  
    gl.useProgram(SsShaderProgram);
    //setLights(SsShaderProgram, worldMatrix);
    setProjectionUniforms(SsShaderProgram, pMatrix, groundPos);
    setspaceShipMatrixUniforms(SsShaderProgram, pMatrix, worldMatrix)
    var numspaceShips = spaceShipList.length;
    var t;

    for (t = 0; t < numspaceShips; ++t) {
        if ((spaceShipList[t].m_life > 0.0) &&
            (spaceShipList[t].m_stage < (BOOM_STAGE - 0.001))) {
            spaceShipList[t].RenderspaceShip(sproingieBuffers, mvMatrix);
        }
    }


    //
    // Render the explosions
    //
    gl.useProgram(sproingieBoomShaderProgram);
    setProjectionUniforms(sproingieBoomShaderProgram, pMatrix, groundPos);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, dotTexture);
    gl.uniform1i(sproingieBoomShaderProgram.uDotSampler, 0);
    
    gl.enable(gl.BLEND);
    for (t = 0; t < numSproingies; ++t) {
        if ((sproingieList[t].m_life > 0.000001) &&
            (sproingieList[t].m_stage >= (BOOM_STAGE - 0.001))) {
            sproingieList[t].RenderSproingieBoom(sproingieBuffers, mvMatrix, dist);
        }
    }
    gl.disable(gl.BLEND);
}

  function nextSproingie(timePassed) {
      var nextStage = timePassed * howfast * 0.333333333;
      var numSproingies = sproingieList.length;
      var t;

      if ((ground += nextStage) >= 12.0) {
          ground -= 12.0;
          for (t = 0; t < numSproingies; ++t) {
              sproingieList[t].m_X -= 1;
              sproingieList[t].m_Y += 2;
              sproingieList[t].m_Z -= 1;
          }
      }

      for (t = 0; t < numSproingies; ++t) {
          sproingieList[t].AdvanceSproingie(nextStage);
      }

      if (target_wait < 0.0) {   /* track to current target */
          var howFar = Math.pow(CAMERA_SLIDE_RATE, (timePassed * 1000.0));
          if (howFar > 0.9999) {
              howFar = 0.9999;
          }

          rotx = target_rx + (howFar * (rotx - target_rx));
          roty = target_ry + (howFar * (roty - target_ry));
          dist = target_dist + (howFar * (dist - target_dist));

          if ((Math.abs(target_rx - rotx) < 0.01) &&
			  (Math.abs(target_ry - roty) < 0.01) &&
			  (Math.abs(target_dist - dist) < 0.01)) {
              target_wait = max_target_wait;
              if (target_dist <= 32) {
                  target_wait *= 0.25;
              }
          }
      }
      else if ((target_wait -= (timePassed * 10.0)) < 0.0) {   /* make up new target */
          var old_dist = target_dist;

          target_wait = -1.0;
          target_rx = myrand(100) - 35;
          target_ry = -myrand(90);
          target_dist = 32 << myrand(2);  /* could be 32, 64, or 128, (previously or 256) */

          if (target_dist >= old_dist) { /* no duplicate distances */
              target_dist *= 2.0;
          }
      }
      /* Otherwise just hang loose for a while here */
  }

function nextspaceShip(timePassed) {
      var nextStage = timePassed * howfast * 0.333333333;
      var numspaceShip = spaceShipList.length;
      var t;

      if ((ground += nextStage) >= 12.0) {
          ground -= 12.0;
          for (t = 0; t < numspaceShip; ++t) {
              spaceShipList[t].m_X -= 1;
              spaceShipList[t].m_Y += 2;
              spaceShipList[t].m_Z -= 1;
          }
      }

      for (t = 0; t < numspaceShip; ++t) {
          spaceShipList[t].AdvancespaceShip(nextStage);
      }

      if (target_wait < 0.0) { /* track to current target */
          var howFar = Math.pow(CAMERA_SLIDE_RATE, (timePassed * 1000.0));
          if (howFar > 0.9999) {
              howFar = 0.9999;
          }

          rotx = target_rx + (howFar * (rotx - target_rx));
          roty = target_ry + (howFar * (roty - target_ry));
          dist = target_dist + (howFar * (dist - target_dist));

          if ((Math.abs(target_rx - rotx) < 0.01) &&
(Math.abs(target_ry - roty) < 0.01) &&
(Math.abs(target_dist - dist) < 0.01)) {
              target_wait = max_target_wait;
              if (target_dist <= 32) {
                  target_wait *= 0.25;
              }
          }
      }
      else if ((target_wait -= (timePassed * 10.0)) < 0.0) { /* make up new target */
          var old_dist = target_dist;

          target_wait = -1.0;
          target_rx = myrand(100) - 35;
          target_ry = -myrand(90);
          target_dist = 32 << myrand(2); /* could be 32, 64, or 128, (previously or 256) */

          if (target_dist >= old_dist) { /* no duplicate distances */
              target_dist *= 2.0;
          }
      }
      /* Otherwise just hang loose for a while here */
  }



  function animate() {
    var timeNow = new Date().getTime();
    if (lastTime !== 0) {
        var timePassed = (timeNow - lastTime) * 0.001;
        fpsTime += timePassed;
        fpsFrames++;

        if (fpsFrames <= 0) {
            fpsTime = timePassed = 0;
        } else if (fpsTime > 2) {
            var fps = fpsFrames / fpsTime;
            $(".showFPS").html(fps.toFixed(2) + " fps");
            fpsFrames = fpsTime = 0;
        }

        if (timePassed > 1.0e-5) {
            if (looking < -0.00001) {
                lookAway += looking * timePassed;

                if (lookAway < 0.0) {
                    lookAway = 0.0;
                    looking = 0.0;
                }
            }

            if (!isPaused) {
                nextSproingie(timePassed);
nextspaceShip(timePassed);
            }
        }

        if (toolbarVisible) {
            toolbarLife -= timePassed;
            if (toolbarLife < 0) {
                toolbarVisible = false;
                $("#toolbar").hide("fade", {}, TOOLBAR_FADE_SPEED);
                //$("body").css('cursor', 'none');
            }
        }
    }
    lastTime = timeNow;
  }


  function tick() {
    requestAnimFrame(tick);
    drawScene();
    animate();
  }

  function handleMouseDown(event) {
      mouseDown = event.button;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
  }

  function handleMouseUp(event) {
      mouseDown = -1;
  }

  function handleMouseMove(event) {
      //document.getElementById("info").innerHTML = "Button " + event.button;
      if (mouseDown < 0) {
          toolbarLife = MAX_TOOLBAR_LIFE;
          if (!toolbarVisible) {
              toolbarVisible = true;
              $("#toolbar").show("fade", {}, TOOLBAR_FADE_SPEED);
              //$("body").css('cursor', 'auto');
          }
          return;
      }

      var dx = event.clientX - lastMouseX;
      var dy = event.clientY - lastMouseY;

      lastMouseX = event.clientX;
      lastMouseY = event.clientY;

      if (mouseDown === 0) {
          target_wait = max_target_wait * 2.0;
          rotx += dy * 0.5;
          roty += dx * 0.5;

          if (rotx < -35.0) { rotx = -35.0; }
          if (rotx > 65.0) { rotx = 65.0; }

          if (roty < -90.0) { roty = -90.0; }
          if (roty > 0.0) { roty = 0.0; }
      }
      else {
          target_wait = max_target_wait * 2.0;
          dist += (dist * -0.01 * dy);

          if (dist < 32.0) { dist = 32.0; }
          if (dist > 256.0) { dist = 256.0; }
      }
  }

  function webGLStart() {
    var canvas = document.getElementById(glCanvasName);
    initGL(canvas);
    if (!gl) { return; }
    window.onresize = resizeGL;
    
    groundShaderProgram = gl.createProgram();
    initShaders(groundShaderProgram, "shader-fs-ground", "shader-vs-ground");
    sproingieShaderProgram = gl.createProgram();
    initShaders(sproingieShaderProgram, "shader-fs-sproingie", "shader-vs-sproingie");
    sproingieBoomShaderProgram = gl.createProgram();
    initBoomShaders(sproingieBoomShaderProgram, "shader-fs-boom", "shader-vs-boom");
 initspaceShipShaders();
    initBuffers();
    initTextures();

    SetMaxSproingies(DEFAULT_NUM_SPROINGIES);
 SetMaxSpaceShips(DEFAULT_NUM_SPROINGIES);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clearDepth(1.0);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    // The original Sproingies used clockwise surfaces,
    // for reasons lost to the sands of time...
    // (Probably because they were modeled in Lightwave 3D back in the 90's...)
    gl.frontFace(gl.CW);
    gl.enable(gl.CULL_FACE);

    canvas.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;

    tick();
  }

  function insertInspector() {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src = "js/webgl-inspector/embed.js";
      document.head.appendChild(script);
  }

  function startup() {
      if (document.URL.indexOf("inspect=1") > 1) {
          window.afterInspectorLoad = webGLStart;
          insertInspector();
      }
      else {
          webGLStart();
      }
  }

  // Slider sets code
  function ReadMaxSproingies(val) {
      val = 101 - val;
      var x = 2.0 - (val / 50.0);
      var y = Math.floor((Math.exp(x * 1.2) * 10.0 - 7.0) + 0.5);

      SetMaxSproingies(y);
      $("#howManyNum").html(y);
      return y;
  }

  // Code sets slider
  function PutMaxSproingies(num) {
      //var num = sproingieList.length;
      $("#howManyNum").html(num);
      var x = Math.log((num + 7.0) / 10.0) / 1.2;
      var y = Math.floor(((2.0 - x) * 50.0) + 0.5);
      y = 101 - y;

      if (y < 1) { y = 1; }
      if (y > 100) { y = 100; }

      return y;
  }

  // Slider sets code
  function ReadHowFast(val) {
      val = 101 - val;
      var x = 2.0 - (val / 50.0);
      var y = Math.floor((Math.exp(x * 1.2) * 10.0 - 7.0) + 0.5);

      howfast = y;
      $("#howFastNum").html(y);
      return y;
  }

  // Code sets slider
  function PutHowFast() {
      $("#howFastNum").html(howfast);
      var x = Math.log((howfast + 7.0) / 10.0) / 1.2;
      var y = Math.floor(((2.0 - x) * 50.0) + 0.5);
      y = 101 - y;

      if (y < 1) { y = 1; }
      if (y > 100) { y = 100; }

      return y;
  }

  $(function() {

      // Add the ".checked()" function to jQuery
      $.fn.checked = function(value) {
          // From http://stackoverflow.com/questions/426258/how-do-i-check-a-checkbox-with-jquery-or-javascript
          //  and http://jsfiddle.net/xixionia/WnbNC/
          if (value === true || value === false) {
              // Set the value of the checkbox
              $(this).each(function() { this.checked = value; });
          } else if (value === undefined || value === 'toggle') {
              // Toggle the checkbox
              $(this).each(function() { this.checked = !this.checked; });
          }
          return $(this);
      };

      var inspectorVisible = (document.URL.indexOf("inspect=1") > 1);

      $("#settingsDialog").dialog({
          autoOpen: false,
          show: "fade",
          hide: "fade",
          width: 325,
          minWidth: 325,
          resizable: false,
          buttons: { "Ok": function() { $(this).dialog("close"); } }
      });

      $("#howManySlider").slider({
          min: 1,
          max: 100,
          value: PutMaxSproingies(DEFAULT_NUM_SPROINGIES),
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { ReadMaxSproingies(ui.value); return true; }
      });
      $("#howFastSlider").slider({
          min: 1,
          max: 100,
          value: PutHowFast(),
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { ReadHowFast(ui.value); return true; }
      });
      $("#howFunkyNum").html(weirdness);
      $("#howFunkySlider").slider({
          min: 0,
          max: 25,
          value: weirdness,
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { weirdness = ui.value; $("#howFunkyNum").html(weirdness); return true; }
      });

      $("#infoDialog").dialog({
          autoOpen: false,
          show: "fade",
          hide: "fade",
          width: 730,
          zIndex: 2000,
          buttons: { "Ok": function() { $(this).dialog("close"); } }
      });

      $("#play").button({
          text: true,
          icons: {
              primary: "ui-icon-pause"
          }
      }).click(function() {
          var options;
          if ($(this).text() === "play") {
              isPaused = false;
              options = {
                  label: "pause",
                  icons: {
                      primary: "ui-icon-pause"
                  }
              };
          } else {
              isPaused = true;
              options = {
                  label: "play",
                  icons: {
                      primary: "ui-icon-play"
                  }
              };
          }
          $(this).button("option", options);
      });
      $("#showInfo").button({
          text: true,
          icons: {
              primary: "ui-icon-info"
          }
      }).click(function() {
          if ($("#infoDialog").is(":visible")) {
              $("#infoDialog").dialog("close");
          } else {
              $("#infoDialog").dialog("open");
          }
      });
      $("#showSettings").button({
          text: true,
          icons: {
              primary: "ui-icon-wrench"
          }
      }).click(function() {
          if ($("#settingsDialog").is(":visible")) {
              $("#settingsDialog").dialog("close");
          } else {
              $("#settingsDialog").dialog("open");
          }
      });
      $("#showInspector").checked(inspectorVisible).button({
          text: true,
          icons: {
              primary: "ui-icon-script"
          }
      }).click(function() {
          document.location = "Sproingies.html" + (inspectorVisible ? "" : "?inspect=1");
      });

      // Move the version text to the bottom of the dialog.
      $(".ui-dialog:has(#infoDialog) .ui-dialog-buttonpane").prepend('<div class="version2">' + $("div.version").html() + "<\/div>");
      $(".version").remove();
      
      // Make an FPS display
      $(".ui-dialog:has(#settingsDialog) .ui-dialog-buttonpane").prepend('<div class="showFPS"><\/div>');
  });
  
</script>

<!-- This section is Google tracking stuff, nothing WebGL related here...  -->
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-21849136-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>
<!-- End of Google tracking stuff. -->

</head>


<body onload="startup();">

  <!-- The parent node of the canvas can get an error written into it by webgl-utils.js. -->
  <div id="canvasContainer">
    <canvas id="glCanvas" width="800" height="600"></canvas>
  </div>

  <div id="loadingWebGL">Loading...</div>

  <div id="missingWebGL"><span class="redBox">Looks like your browser doesn't support WebGL.</span>
      <a href="http://learningwebgl.com/blog/?p=11" target="_blank">Quick fix: get a browser that supports WebGL</a>
  </div>

    <div id="toolbar">
        <button id="play">pause</button>
        <button id="showInfo">info</button>

        <input type="checkbox" id="showInspector" /><label for="showInspector">inspector</label>
        <button id="showSettings">settings</button>
    </div>
    
    <div id="settingsDialog" title="Sproingies settings">
        <div id="settingsSliders">
            <div class="sliderBox ui-widget ui-corner-all">
                <p>How<br />many</p>

                <span id="howManySlider"></span>
                <p id="howManyNum">&nbsp;</p>
            </div>
            <div class="sliderBox ui-widget ui-corner-all">
                <p>How<br />fast</p>
                <span id="howFastSlider"></span>
                <p id="howFastNum">&nbsp;</p>
            </div>

            <div class="sliderBox ui-widget ui-corner-all">
                <p>How<br />funky</p>
                <span id="howFunkySlider"></span>
                <p id="howFunkyNum">&nbsp;</p>
            </div>
        </div>
    </div>
    
    <div id="infoDialog" title="About the Sproingies">

	    <p><a href="https://bitbucket.org/emackey/sproingies/wiki" target="_blank"><img
              class="infoIcon" src="images/icon_Sproingie.jpg" alt="Sproingie" width="72" height="72" /></a>
	       After years of seclusion, the youngest generation of Sproingies make an appearence
           on a WebGL canvas.  Code by
           <a href="http://twitter.com/emackey" target="_blank">@emackey</a> based on
           <a href="http://learningwebgl.com/" target="_blank">Learning WebGL</a> and
           other sources.  Original Sproingie design by Al Mackey.
        </p>
        <p>Sproingies have a long journey behind them, beginning in
           <a href="http://avl.enemy.org/Gallery/sproingy/" target="_blank">1997</a>, and they
           have a long journey ahead of them. Luckily they are bouncy and full of energy.
           They are also nontoxic, safe for pets and small children.
        </p>
        <p>Read more about them on the
           <a href="https://bitbucket.org/emackey/sproingies/wiki" target="_blank">Sproingie Wiki</a>,
           or download their source code from the
           <a href="https://bitbucket.org/emackey/sproingies/src/tip/webgl/" target="_blank">Sproingie Repository</a>.
        </p>

        <div class="version">Version 1.0a, last modified 5 June 2011.</div>
    </div>

</body></html>